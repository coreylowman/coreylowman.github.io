---
title: "Tensors with dimensions sized at both compile and run time"
---

Up front, this is what we are building towards:

```rust
let _: Tensor<(Const<2>, Const<3>)> = ...
let _: Tensor<Rank2<2, 3>> = ...
let _: Tensor<(Dyn, Dyn)> = ...
let _: Tensor<(Dyn, Const<4>, Const<5>)> = ...
let _: Tensor<(Const<1>, Dyn, Const<2>, Dyn)> = ...
```

# What is an array?

Short version:

1. a slice (pointer and length) of data
2. the number of dimensions
3. the strides (the offsets between each element of the array for each dimension)

Normally arrays are just described by their shape, which can give you both number of dimensions and strides. An Array of shape `(2, 3)`, is a 2 dimensional array, and has strides `[3, 1]`. In rust types this would be represented by `[[T; 3]; 2]`.

The whole point of this post is to show how to use `(2, 3)` as both a type (compile time shape) and a value (run time shape):

```rust
let _: Tensor<(2, usize)> = zeros((2, 3));
let _: Tensor<(2, 3)> = zeros();
let _: Tensor<(usize, usize)> = zeros((42, 43));
```

# Turning numbers into types

The first thing we need to figure out is how to use numbers as types.

Yes you read that right. **Numbers themselves as types.**

Not "the type of `x` is int", rather "the type of x is **5**" (for example):
```rust
let a: 5 = ???;
```

That's what we mean by numbers as types, and **rust let's you do this!**

Here's the magic trick:
```rust
struct Const<const N: usize>;
```

This is a zero sized type - it has no runtime data associated with it. However we have tagged it with a const generic value, meaning it has data at compile time!

Now numbers can be types:
```rust
// it's type is `5`! ðŸ¤¯
let a: Const<5> = Const;
```

Now that we have our magical trick to turn numbers into types, we can start building our shapes.

# Shapes that mix compile and run time dimensions

### The `Dim` trait

All shapes are made up of N dimensions. What is a dimension exactly? Well it's just something that has a size

```rust
trait Dim {
    fn size(&self) -> usize;
}
```

Now that we have our `Const` struct and our `Dim` trait, we just need something to represent runtime dimensions. You could do a lot of things here, like just use a `usize` directly, but I chose to have a really
simple wrapper type:

```rust
struct Dyn(usize);
```

I think the name of this is more clear to its purpose. There are some shortcomings with the name, but I haven't been able to figure out a better one.

Now we just impl the `Dim` trait for both our types of dimensions:
```rust
impl<const N: usize> Dim for Const<N> {
    fn size(&self) -> usize {
        N
    }
}

impl Dim for Dyn {
    fn size(&self) -> usize {
        self.0
    }
}
```

### The `Shape` trait

I'd like to build shapes like this (same snippet from the beginning):

```rust
let _: Tensor<(Const<2>, Const<3>)> = ...
let _: Tensor<Rank2<2, 3>> = ...
let _: Tensor<(Dyn, Dyn)> = ...
let _: Tensor<(Dyn, Const<4>, Const<5>)> = ...
let _: Tensor<(Const<1>, Dyn, Const<2>, Dyn)> = ...
```

i.e. I want tuples to represent shapes, but also I don't want to type out Const every time.

For the second piece, we can just have some simple type aliases for purely compile time shapes:

```rust
type Rank0 = ();
type Rank1<const M: usize> = (Const<M>, );
type Rank2<const M: usize, const N: usize> = (Const<M>, Const<N>);
// etc...
```

Ultimately we can just represent shapes as tuples of `Dim`s:

```rust
impl Shape for () {
    ...
}

impl<D1: Dim> Shape for (D1, ) {
    ...
}

impl<D1: Dim, D2: Dim> Shape for (D1, D2) {
    ...
}
```

But what should go in this `Shape` trait? Well going back to our original definition of an array, the main
parts are strides and number of dimensions, so those are pretty much it:

```rust
trait Shape {
    const NUM_DIMS: usize;
    fn strides(&self) -> [usize; Self::NUM_DIMS];
}
```

> Note: astute readers may notice that i've used a nightly feature with `[usize; Self::NUM_DIMS]`. My actual implementation of all of this doesn't use this, but for the blog its the most clear.

And here are how we'd fill out the impls:

```rust
impl Shape for () {
    const NUM_DIMS: usize = 0;
    fn strides(&self) -> [usize; Self::NUM_DIMS] {
        []
    }
}

impl<D1: Dim> Shape for (D1, ) {
    const NUM_DIMS: usize = 1;
    fn strides(&self) -> [usize; Self::NUM_DIMS] {
        [1]
    }
}

impl<D1: Dim, D2: Dim> Shape for (D1, D2) {
    const NUM_DIMS: usize = 2;
    fn strides(&self) -> [usize; Self::NUM_DIMS] {
        [self.1.size(), 1]
    }
}
// etc
```

That's it!

Of course, you could also impl shape for anything else other than tuples, which is the beauty of rust.

# Why is this useful though?

This provides the ultimate flexibility of specifying shapes at compile time to enforce shape restrictions,
but also allowing things to be specified at runtime.

Here are some motivation examples.

### A clean matrix multiplication api

For example, matrix multiplication between two tensors requires 3 different dimensions:
1. The left matrix is of shape `(M, K)`
2. The right matrix is of shape `(K, N)`
3. The resulting matrix is of shape `(M, N)`

The only requirement is that the `K` dimension is the same between both - we don't care what `M` and `N`
are.

*This is where our compile time dimensions come into play!* We can represent these like so:

```rust
fn matmul<M: Dim, const K: usize, N: Dim>(
    lhs: Tensor<(M, Const<K>)>,
    rhs: Tensor<(Const<K>, N)>,
) -> Tensor<(M, N)> {
    ...
}
```

Now the k dimension is enforced to be the same *at compile time*, but the other dimensions can be whatever you want them to be (e.g. both `Dyn`, both `Const`, or some mix of the two)

### Generic dimensions, regardless of compile vs runtime

This is also really nice for things that don't care about enforcing shape constraints, like an element-wise operation:

```rust
fn relu<S: Shape>(t: Tensor<S>) -> Tensor<S> {
    ...
}
```
Here the shape could be *anything*!

You can also write code generic over specific dimensions, like a batch dimension for machine learning applications:

```rust
impl MnistDataset {
    fn get_batch<Batch: Dim>(&self) -> Tensor<(Batch, Const<28>, Const<28>)> {
        ...
    }
}
```

# Actual implementation

You can find my actual implementation (of up to 6 dimensions) in my [dfdx](https://github.com/coreylowman/dfdx) crate. This was just recently added with a big refactor, and will be available on crates.io on the next release.

In addition to being able to create tensors with shapes like I've described above, there are a ton
of operations you can do on tensors like matrix multiplication, elementwise operations, etc, that all utilize
the shape traits.

Actually 99% of the operations I've implemented are just generic over shape. Really only
matrix multiplication, convolutions, and multi head attention (from transformers) require compile time checks.

# Final words & thank you

The end result is very satisfying to me, and I constantly feel like I'm discovering something new rust can do.
Hopefully this is useful to people, let me know if you have other ideas!

Finally, thank you to [@skinner](https://github.com/skinner), [@iExalt](https://github.com/iExalt), and the rest of my [generous sponsors](https://github.com/sponsors/coreylowman/). Your continued support is very much appreciated.
